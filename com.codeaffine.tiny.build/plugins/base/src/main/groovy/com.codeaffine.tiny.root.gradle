plugins {
    id("pl.allegro.tech.build.axion-release")
}

scmVersion {
    tag {
        prefix = 'v'
    }
    releaseBranchNames = ['main']
    repository {
        pushTagsOnly = true // needed for CI/CD trigger
    }
}

project.version = scmVersion.version

def allowedIncrementsForBranch(String branch) {
    if (branch.startsWith("hotfix/")) {
        return ['incrementPatch']
    }
    def scmExt = project.extensions.findByName('scmVersion')
    def releaseBranches = scmExt?.releaseBranchNames?.get() ?: []
    if (releaseBranches.contains(branch)) {
        return ['incrementMinor', 'incrementMajor']
    }
    return []
}

def assertOnReleaseBranch(String incrementer) {
    def currentBranch = ['git', 'rev-parse', '--abbrev-ref', 'HEAD'].execute().text.trim()
    def scmExt = project.extensions.findByName('scmVersion')
    def releaseBranches = scmExt?.releaseBranchNames?.get() ?: []
    def allowed = allowedIncrementsForBranch(currentBranch)
    if (allowed.isEmpty()) {
        throw new GradleException("❌ Releases are not allowed on branch '${currentBranch}'.")
    }
    if (!allowed.contains(incrementer)) {
        throw new GradleException("❌ On branch '${currentBranch}', only allowed increments are: ${allowed}. Tried: '${incrementer}'")
    }
    if (currentBranch.startsWith("hotfix/")) {
        def baseTagFound = releaseBranches.any { releaseBranch ->
            def baseCommit = ['git', 'merge-base', 'HEAD', "origin/${releaseBranch}"].execute().text.trim()
            def tagsOnBase = ['git', 'tag', '--points-at', baseCommit].execute().text.trim()
            if (!tagsOnBase.isEmpty()) {
                return true
            }
            return false
        }
        if (!baseTagFound) {
            throw new GradleException("❌ Hotfix '${currentBranch}' is not based on any tagged commit from release branches: ${releaseBranches}")
        }
    }
}

static def assertNoUncommittedChanges() {
    def status = ['git', 'status', '--porcelain'].execute().text.trim()
    if (!status.isEmpty()) {
        throw new GradleException("❌ Uncommitted changes detected:\n${status}")
    }
}

def assertTagDoesNotExist() {
    def version = project.extensions.scmVersion.version
    def tagName = "v${version}"

    // Check local tags
    def localTags = ['git', 'tag'].execute().text.readLines()
    if (localTags.contains(tagName)) {
        throw new GradleException("❌ Tag '${tagName}' already exists locally.")
    }

    // Check remote tags
    def remoteOutput = ['git', 'ls-remote', '--tags', 'origin', tagName].execute().text.trim()
    if (!remoteOutput.isEmpty()) {
        throw new GradleException("❌ Tag '${tagName}' already exists on remote (origin).")
    }
}

static def assertLocalBranchSynchronized() {
    def branch = ['git', 'rev-parse', '--abbrev-ref', 'HEAD'].execute().text.trim()
    ['git', 'fetch', 'origin'].execute().waitFor()
    def behind = ['git', 'rev-list', '--left-only', '--count', "HEAD...origin/${branch}"].execute().text.trim().toInteger()
    def ahead  = ['git', 'rev-list', '--right-only', '--count', "HEAD...origin/${branch}"].execute().text.trim().toInteger()
    if (behind > 0 || ahead > 0) {
        throw new GradleException(
            "Local branch '${branch}' is not synchronized with origin/${branch} (ahead: ${ahead}, behind: ${behind}). Please sync before releasing."
        )
    }
}

/**
 * Registers a wrapper release task that asserts the branch and runs Axion's 'release'
 * with the given version incrementer (e.g. 'incrementPatch').
 *
 * @param taskName the name of the new Gradle task (e.g. 'releasePatch')
 * @param incrementer the Axion version increment strategy (e.g. 'incrementPatch')
 */
def registerReleaseTask(String taskName, String incrementer) {
    tasks.register(taskName) {
        group = mainBuildGroup
        description = "Release new ${incrementer - 'increment'} version and push to remote"

        doLast {
            assertOnReleaseBranch(incrementer)
            assertNoUncommittedChanges()
            assertTagDoesNotExist()
            assertLocalBranchSynchronized()
            project.ext.set('release.versionIncrementer', incrementer)

            // Execute the actions of the existing 'release' task manually
            tasks.release.actions.each { it.execute(tasks.release) }
        }
    }
}

/**
 * Registers an aggregate task that delegates to all subprojects that have a task with the same name.
 *
 * @param taskName the name of the top-level task (e.g. 'javadoc', 'publish', etc.)
 * @param taskDescription the description for the task
 */
def registerAggregateTask(String taskName, String taskDescription) {
    tasks.register(taskName) {
        group = mainBuildGroup
        description = taskDescription
        dependsOn(subprojects.collect { subproject ->
            //noinspection ConfigurationAvoidance: named does not work
            def task = subproject.tasks.findByName(taskName)
            task ? ":${subproject.name}:${task.name}" : null
        }.findAll { it != null })
    }
}

// Configure the ':tasks' task of the root project to only show
// the main lifecycle tasks as entry points to the build
ext.mainBuildGroup = "main build"

tasks.named("tasks") {
    displayGroup = mainBuildGroup
}

tasks.register("build") {
    group = mainBuildGroup
    description = "Complete build of all modules and the application"
    dependsOn(subprojects.collect { ":${it.name}:$name" })
}

tasks.register("clean") {
    group = mainBuildGroup
    description = "Run clean of all modules and the application"
    dependsOn(subprojects.collect { ":${it.name}:$name" })
}

registerAggregateTask("javadoc", "Run javadoc of all modules and the application")
registerAggregateTask("javadocJar", "Run javadocJar of all modules and the application")
registerAggregateTask("testFixturesJavadoc", "Run javadoc for test fixtures of all related modules")
registerAggregateTask("testFixturesJavadocJar", "Run javadocJar for test fixtures of all related modules")
registerAggregateTask("recommendModuleVersions", "Run recommendModuleVersions of all modules and the application")
registerAggregateTask("moduleDependencies", "Run moduleDependencies of all modules and the application")
registerAggregateTask("publish", "Run publish of all modules")
registerReleaseTask('releaseMajor', 'incrementMajor')
registerReleaseTask('releaseMinor', 'incrementMinor')
registerReleaseTask('releasePatch', 'incrementPatch')
