import java.text.SimpleDateFormat

plugins {
    id("com.codeaffine.tiny.base")
    id("java")
    id("io.freefair.lombok")
    id("com.diffplug.spotless")
    id("jvm-test-suite")
    id("jacoco")
}

ext {
    isRuntimeOnly = false // attribute indicates if the dependency gets scoped as runtime only when used in a BOM
}

java {
    toolchain.languageVersion.set(JavaLanguageVersion.of(readJavaVersion(project)))
    withSourcesJar()
}

tasks.withType(JavaCompile.class).configureEach {
    options.encoding = "UTF-8"
}

configurations {
    mockitoAgent
}

dependencies {
    compileOnly(
            libs.lombok
    )
    testImplementation(
            libs.bundles.junit.jupiter.apis,
            libs.assertj.core,
            libs.mockito.core,
    )
    mockitoAgent(libs.mockito.core) {
        transitive = false
    }
}

testing {
    suites {
        test {
            useJUnitJupiter()
        }
    }
}

test {
    jvmArgs = [
        "-Xshare:off",
        "-javaagent:${configurations.mockitoAgent.asPath}"
    ]
    useJUnitPlatform()
    finalizedBy jacocoTestReport
}

jacocoTestReport {
    dependsOn test
    reports {
        xml.required = true
        html.required = true
    }
}

spotless {
    java {
        licenseHeaderFile project.parent.file("COPYRIGHT.txt")
    }
}

javadoc {
    options {
        encoding = 'UTF-8'
        stylesheetFile = project.parent.file('javadoc/stylesheet.css')
        windowTitle = 'TINY API'
        header = '<a href="https://codeaffine.com"><img class="logo" src="https://www.codeaffine.com/wp-content/uploads/2014/07/logo.svg" alt="Code Affine"></a>'
    }
}

tasks.register("javadocJar", Jar) {
    from(tasks.javadoc)
    archiveClassifier.set("javadoc")
}

tasks.register('addMainLicense', Copy) {
    if(needLicenceFile(project, 'main', "${projectDir}/src/main/")) {
        from(project.parent.file('LICENSE'))
        into("${projectDir}/src/main/resources/META-INF")
    }
}

private static boolean needLicenceFile(Project project, sourceSetName, sourceSetDir) {
    def result = false
    project.sourceSets.each {
        result |= it.name == sourceSetName && new File(sourceSetDir).exists()
    }
    return result
}

private static String readJavaVersion(Project project) {
    def result = project.providers
            .fileContents(project.rootProject.layout.projectDirectory.file("VERSION_JAVA"))
            .getAsText()
            .getOrElse("")
            .trim()
    if(result == "") {
        throw new GradleException("${project.rootProject.layout.projectDirectory}/VERSION_JAVA is empty")
    }
    return result
}

processResources {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    from(tasks.named("addMainLicense"))
}

jar {
    manifest {
        attributes(
            'Name'                    : project.name.replace('.', '/'),
            'Implementation-Title'    : project.name,
            'Implementation-Version'  : project.version,
            'Implementation-Vendor-Id': "com.codeaffine",
            'Build-Timestamp'         : new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ").format(new Date()),
            'Build-Revision'          : project.ext.headHash,
            'Created-By'              : "Gradle ${gradle.gradleVersion}",
            'Build-Jdk'               : "${System.properties['java.version']} (${System.properties['java.vendor']} ${System.properties['java.vm.version']})",
            'Build-OS'                : "${System.properties['os.name']} ${System.properties['os.arch']} ${System.properties['os.version']}"
        )
    }
}

sourcesJar {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    from(tasks.named("addMainLicense"))
}
