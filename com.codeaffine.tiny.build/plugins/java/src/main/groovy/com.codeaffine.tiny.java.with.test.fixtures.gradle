import org.gradle.api.internal.project.ProjectInternal
import org.gradle.api.plugins.internal.JavaConfigurationVariantMapping
import org.gradle.api.plugins.internal.JavaPluginHelper
import org.gradle.api.plugins.internal.JvmPluginsHelper
import org.gradle.internal.component.external.model.ProjectDerivedCapability
import org.gradle.internal.component.external.model.TestFixturesSupport
import org.gradle.jvm.component.internal.DefaultJvmSoftwareComponent

import java.text.SimpleDateFormat
import java.util.regex.Matcher

plugins {
    id("com.codeaffine.tiny.java.base")
    id("java-test-fixtures")
}

dependencies {
    testFixturesImplementation(
        libs.bundles.junit.jupiter.apis,
        libs.assertj.core,
        libs.mockito.core
    )
}

testFixturesJavadoc {
    options {
        encoding = 'UTF-8'
        stylesheetFile = project.parent.file('javadoc/stylesheet.css')
        windowTitle = 'TINY API'
        header = '<a href="https://codeaffine.com"><img class="logo" src="https://www.codeaffine.com/wp-content/uploads/2014/07/logo.svg" alt="Code Affine"></a>'
    }
}

if (plugins.hasPlugin('java')) {
    tasks.register('copyTestFixturesJavadocAssets', Copy) {
        from("${rootProject.projectDir}/javadoc/resources")
        into(layout.buildDirectory.dir('docs/javadoc/resources'))
        include('fonts/**', 'prism/**')
    }

    tasks.register('injectTestFixturesPrismScript') {
        dependsOn tasks.named('testFixturesJavadoc')

        doLast {
            def javadocDir = layout.buildDirectory.dir('docs/javadoc').get().asFile
            if (!javadocDir.exists()) {
                return
            }

            def scriptTag = '''<script>
            (function(){
              var path = window.location.pathname;
              var base = path.substring(path.indexOf('/docs/javadoc/') + 14);
              var depth = (base.match(/\\//g) || []).length;
              var relativePath = '../'.repeat(depth) + 'resources/prism/prism.js';
              var s = document.createElement('script');
              s.src = relativePath;
              document.body.appendChild(s);
            })();
            </script>'''
            javadocDir.eachFileRecurse { file ->
                if (file.name.endsWith('.html')) {
                    def content = file.text
                    if (!content.contains('prism.js')) {
                        file.text = content.replaceFirst('</body>', Matcher.quoteReplacement(scriptTag + '\n</body>'))
                    }
                }
            }
        }
    }

    tasks.matching { it.name == 'testFixturesJavadocJar' }.configureEach {
        dependsOn(tasks.named('copyTestFixturesJavadocAssets'))
    }

    tasks.named('testFixturesJavadoc') {
        finalizedBy(
                tasks.named('copyTestFixturesJavadocAssets'),
                tasks.named('injectTestFixturesPrismScript')
        )
    }
}

tasks.register("testFixturesJavadocJar", Jar) {
    from(tasks.testFixturesJavadoc)
    archiveClassifier.set("test-fixtures-javadoc")
}

tasks.register('addTestFixturesLicense', Copy) {
    if(needLicenceFile(project, 'testFixtures', "${projectDir}/src/testFixtures/")) {
        from(project.parent.file('LICENSE'))
        into("${projectDir}/src/testFixtures/resources/META-INF")
    }
}

private static boolean needLicenceFile(Project project, sourceSetName, sourceSetDir) {
    def result = false
    project.sourceSets.each {
        result |= it.name == sourceSetName && new File(sourceSetDir).exists()
    }
    return result
}

processTestFixturesResources {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    from(tasks.named("addTestFixturesLicense"))
}

testFixturesJar {
    manifest {
        attributes(
            'Implementation-Title'    : project.name,
            'Implementation-Version'  : project.version,
            'Implementation-Vendor-Id': "com.codeaffine",
            'Build-Timestamp'         : new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ").format(new Date()),
            'Build-Revision'          : project.ext.headHash,
            'Created-By'              : "Gradle ${gradle.gradleVersion}",
            'Build-Jdk'               : "${System.properties['java.version']} (${System.properties['java.vendor']} ${System.properties['java.vm.version']})",
            'Build-OS'                : "${System.properties['os.name']} ${System.properties['os.arch']} ${System.properties['os.version']}"
        )
    }
}

// workaround to generate test fixtures sources jar taken from https://github.com/gradle/gradle/issues/20539
def testFixturesSourceSet = sourceSets.named(TestFixturesSupport.TEST_FIXTURE_SOURCESET_NAME).get()
JavaPluginExtension javaPluginExtension = project.getExtensions().findByType(JavaPluginExtension.class)
JvmPluginsHelper.configureJavaDocTask(TestFixturesSupport.TEST_FIXTURE_SOURCESET_NAME, testFixturesSourceSet, tasks, javaPluginExtension)
def capabilities = [new ProjectDerivedCapability(project, "testFixtures")]
def sourceElements = JvmPluginsHelper.createDocumentationVariantWithArtifact(
        testFixturesSourceSet.sourcesElementsConfigurationName,
        TestFixturesSupport.TEST_FIXTURE_SOURCESET_NAME,
        DocsType.SOURCES,
        capabilities as Set<Capability>,
        testFixturesSourceSet.sourcesJarTaskName,
        testFixturesSourceSet.allSource,
        project as ProjectInternal
)

def component = JavaPluginHelper.getJavaComponent(project) as DefaultJvmSoftwareComponent
component.addVariantsFromConfiguration(sourceElements, new JavaConfigurationVariantMapping("runtime", true))

testFixturesSourcesJar {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    dependsOn(tasks.named("addTestFixturesLicense"))
}
